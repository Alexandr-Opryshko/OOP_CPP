#include"Header.h"

///////////////////////////////////////////////////////////////////////////////
////////////////////////////// CLASS DEFINITION ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template<typename T>
List<T>::Element::Element(T Data, Element* pNext, Element* pPrev) :Data(Data), pNext(pNext), pPrev(pPrev) {
	cout << "EConstructor:\t" << this << endl;
}
template<typename T>
List<T>::Element::~Element() {
	cout << "EDestructor:\t" << this << endl;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////    ITERATOR    ////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

template<typename T>
List<T>::Iterator::Iterator(Element* Temp) {
	this->Temp = Temp;
	cout << "ItConstructor:\t" << this << endl;
}
template<typename T>
List<T>::Iterator::~Iterator() {
	cout << "ItDestructor:\t" << this << endl;
}
template<typename T>
typename List<T>::Iterator& List<T>::Iterator::operator++() {
	Temp = Temp->pNext;
	return *this;
}
template<typename T>
typename List<T>::Iterator& List<T>::Iterator::operator--() {
	Temp = Temp->pPrev;
	return *this;
}
template<typename T>
typename List<T>::Iterator& List<T>::Iterator::operator++(int) {
	Temp = Temp->pNext;
	return *this;
}
template<typename T>
typename List<T>::Iterator& List<T>::Iterator::operator--(int) {
	Temp = Temp->pPrev;
	return *this;
}
template<typename T>
bool List<T>::Iterator::operator!=(const Iterator& other) const {
	return this->Temp != other.Temp;
}
template<typename T>
bool List<T>::Iterator::operator!=(Element* other_el) const {
	return this->Temp != other_el;
}
template<typename T>
const T& List<T>::Iterator::operator*() const {
	return Temp->Data;
}
template<typename T>
T& List<T>::Iterator::operator*() {
	return Temp->Data;
}
// замена Temp != nulptr на Temp
template<typename T>
List<T>::Iterator::operator bool()const {
	return Temp;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////    REVERSITERATOR    //////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template<typename T>
List<T>::ReversIterator::ReversIterator(Element* Temp) {
	this->Temp = Temp;
	cout << "ReversItConstructor:\t" << this << endl;
}
template<typename T>
List<T>::ReversIterator::~ReversIterator() {
	cout << "ReversItDestructor:\t" << this << endl;
}
template<typename T>
typename List<T>::ReversIterator& List<T>::ReversIterator::operator++() {
	Temp = Temp->pPrev;
	return *this;
}
template<typename T>
typename List<T>::ReversIterator& List<T>::ReversIterator::operator--() {
	Temp = Temp->pNext;
	return *this;
}
template<typename T>
typename List<T>::ReversIterator& List<T>::ReversIterator::operator++(int) {
	Temp = Temp->pPrev;
	return *this;
}
template<typename T>
typename List<T>::ReversIterator& List<T>::ReversIterator::operator--(int) {
	Temp = Temp->pNext;
	return *this;
}
template<typename T>
bool List<T>::ReversIterator::operator!=(const ReversIterator& other) const {
	return this->Temp != other.Temp;
}
template<typename T>
bool List<T>::ReversIterator::operator!=(Element* other_el) const {
	return this->Temp != other_el;
}
template<typename T>
const T& List<T>::ReversIterator::operator*() const {
	return Temp->Data;
}
template<typename T>
T& List<T>::ReversIterator::operator*() {
	return Temp->Data;
}
template<typename T>
List<T>::ReversIterator::operator bool()const {
	return Temp;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////    LIST    ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template<typename T>
typename const List<T>::Iterator List<T>::begin() const {
	return Head;
}
template<typename T>
typename const List<T>::Iterator List<T>::end() const {
	return nullptr;
}
template<typename T>
typename const List<T>::ReversIterator List<T>::rbegin() const {
	return Tail;
}
template<typename T>
typename const List<T>::ReversIterator List<T>::rend() const {
	return nullptr;
}
// конструктор
template<typename T>
List<T>::List() {
	Head = Tail = nullptr;
	size = 0;
	cout << "LConstructor:\t" << this << endl;
}
// конструктор копирования
template<typename T>
List<T>::List(const List& other) :List() {
	for (Element* Temp = other.Head;Temp;Temp = Temp->pNext)
		push_back(Temp->Data);
}
// конструктор с переменным колличеством параметров
template<typename T>
List<T>::List(const std::initializer_list<T>& il) : List() {
	for (const T* it = il.begin(); it != il.end(); it++) {
		push_back(*it);
	}
	cout << "ConstructorVariableParameters:\t" << this << endl;
}
template<typename T>
List<T>::~List() {
	while (Head != nullptr) pop_front();
	size = 0;
	cout << "LDestructor:\t" << this << endl;
}
//---------------------------------------------------------------------
// Method
// добавить в начало списка
template<typename T>
void List<T>::push_front(T Data) {
	if (Head == nullptr && Tail == nullptr)						// если список пустой
		Head = Tail = new Element(Data);						// то для начала и хвоста присвоим адрес элемента
	else Head = Head->pPrev = new Element(Data, Head);			// иначе указателю первого элемента  и голове присвоим адрес нового элемента
	size++;														// увеличим список на 1 элемент
}
// удаление первого элемента
template<typename T>
void List<T>::pop_front() {
	if (Head == nullptr && Tail == nullptr) return;				// проверка наличия элементов в списке
	else if (size == 1) {										// если остался последний элемент
		delete Tail;											// удалим элемент
		Head = Tail = nullptr;									// и очистим указатели
	}
	else {														// иначе больше чем один элемент в списке
		Head = Head->pNext;										// исключаем элемент из списка
		delete Head->pPrev;										// удаляем элемент из памяти
		Head->pPrev = nullptr;									// и очищаем указатель на удаленный элемент
	}
	size--;														// уменьшим список на 1 элемент
}
// добавить в конец списка
template<typename T>
void List<T>::push_back(T Data) {
	if (Head == nullptr && Tail == nullptr)						// если список пустой
		Head = Tail = new Element(Data);						// то для начала и хвоста присвоим адрес элемента
	else Tail = Tail->pNext = new Element(Data, nullptr, Tail);	// иначе указателю последнего элемента  и хвосту присвоим адрес нового элемента
	size++;														// увеличим список на 1 элемент
}
// удаление последнего элемента
template<typename T>
void List<T>::pop_back() {
	if (Head == nullptr && Tail == nullptr) return;				// если список пустой
	else if (size == 1) {										// если остался последний элемент
		delete Tail;											// удалим элемент
		Head = Tail = nullptr;									// и очистим указатели
	}
	else {														// иначе в списке более одного элемента
		Tail = Tail->pPrev;										// запишим в хвост адрес предпоследнего элемента
		delete Tail->pNext;										// удалим последний элемент
		Tail->pNext = nullptr;									// и очистим указатель на удаленный элемент
	}
	size--;														// уменьшим колличество элементов в списке на один
}
// вставить значение по индексу
template<typename T>
bool List<T>::insert(T data, int index) {
	if (index > (size) || index < 0) return false;
	else if (index == 0) {										// если вставка на место первого элемента
		push_front(data); return true;							// то вызовем метод
	}
	else if (index == size) {									// если вставка на место последнего элемента
		push_back(data); return true;							// то вызовем метод
	}
	else if ((size / 2) >= index) {								// если вставка до середины списка
		Element* Temp = Head;									// возьмем адрес головы листа
		while (index--) {										// дойдем до указанного места
			Temp = Temp->pNext;									// по списку
		}
		Temp->pPrev->pPrev->pNext = Temp->pPrev = new Element(data, Temp, Temp->pPrev);
	}
	else {														// иначе индекс ближе к хвосту
		Element* Temp = Tail;									// возьмем адрес хвоста
		index = size - index - 1;								// установим значение счетчика с хвоста
		while (index--) {										// дойдем до указанного места
			Temp = Temp->pPrev;									// по списку
		}
		Temp->pPrev->pPrev->pNext = Temp->pPrev = new Element(data, Temp, Temp->pPrev);
	}
	size++;														// увеличим список на 1 элемент
	return true;
}
// удаление элемента по индексу
template<typename T>
bool List<T>::erase(int index) {
	if (index > (size - 1) || index < 0) return false;			// индекс за пределами списка
	else if (index == 0) {										// если удаление первого элемента
		pop_front(); return true;								// то вызовем метод
	}
	else if (index == size - 1) {								// если удаление последнего элемента
		pop_back(); return true;								// то вызовем метод
	}
	else if ((size / 2) >= index) {								// если удаление до середины списка
		Element* Temp = Head;									// возьмем адрес головы листа
		while (index--) {										// дойдем до указанного места
			Temp = Temp->pNext;									// по списку
		}
		Temp->pPrev->pNext = Temp->pNext;						// 
		Temp->pNext->pPrev = Temp->pPrev;						// 
		delete Temp;
	}
	else {														// иначе индекс ближе к хвосту
		Element* Temp = Tail;									// возьмем адрес хвоста
		index = size - index - 1;								// установим значение счетчика с хвоста
		while (index--) {										// дойдем до указанного места
			Temp = Temp->pPrev;									// по списку
		}
		Temp->pPrev->pNext = Temp->pNext;
		Temp->pNext->pPrev = Temp->pPrev;
		delete Temp;
	}
	size--;														// уменьшим список на 1 элемент
	return true;
}
//CopyMethods;
template<typename T>
List<T>& List<T>::operator =(const List& Head) {
	if (this->Head == Head.Head)return *this;
	if (this->Head == nullptr && this->Tail == nullptr) {					// если список пуст
		this->Head = this->Tail = new Element(Head.Head->Data);				// запишим первый элемент
		this->size = 1;														// отметим колличество элементов
		for (Element* temp = Head.Head->pNext; temp;temp = temp->pNext) {	// запишим остальные данные списка
			Tail = Tail->pNext = new Element(temp->Data, nullptr, Tail);
			size++;
		}
	}
	else if (this->size >= Head.size) {										// если переданные список меньше или равен приемному
		int sizeTemp = 0;
		Element* TempThis = this->Head;										// возьмем адрес приемного списка
		Element* Temp = Head.Head;											// возьмем адрес передаваемогосписка
		for (int i = 0; i < Head.size; i++) {								// выполняем пока не перезапишим приемный список
			TempThis->Data = Temp->Data;									// данными переданного списка
			TempThis = TempThis->pNext;										// переход к следующему элементу приемного списка
			Temp = Temp->pNext;												// переход к следующему элементу передающего списка
			sizeTemp++;
		}
		while (sizeTemp != this->size) {									// удаляем лишние элементы
			pop_back();														// через метод
		}
	}
	else {																	// иначе приемный список меньше
		Element* TempThis = this->Head;										// возьмем адрес приемного списка
		Element* Temp = Head.Head;											// возьмем адрес передаваемогосписка
		for (int i = 0; i < size; i++) {									// выполняем пока не перезапишим приемный список
			TempThis->Data = Temp->Data;									// данными переданного списка
			TempThis = TempThis->pNext;										// переход к следующему элементу приемного списка
			Temp = Temp->pNext;												// переход к следующему элементу передающего списка
		}
		for (; Temp; Temp = Temp->pNext) {									// добавление элементов
			push_back(Temp->Data);											// через метод
		}
	}
	cout << "AssignConstructor:\t" << this << endl;
	return *this;
}
//MoveMethods;
template<typename T>
List<T>& List<T>::operator =(List&& Head) {
	if (this->Head == Head.Head)return *this;
	if (this->Head == nullptr && this->Tail == nullptr) {					// если список пуст
		this->Head = this->Tail = new Element(Head.Head->Data);				// запишим первый элемент
		this->size = 1;														// отметим колличество элементов
		for (Element* temp = Head.Head->pNext; temp;temp = temp->pNext) {	// запишим остальные данные списка
			Tail = Tail->pNext = new Element(temp->Data, nullptr, Tail);
			size++;
		}
	}
	else if (this->size >= Head.size) {										// если переданные список меньше или равен приемному
		int sizeTemp = 0;
		Element* TempThis = this->Head;										// возьмем адрес приемного списка
		Element* Temp = Head.Head;											// возьмем адрес передаваемогосписка
		for (int i = 0; i < Head.size; i++) {								// выполняем пока не перезапишим приемный список
			TempThis->Data = Temp->Data;									// данными переданного списка
			TempThis = TempThis->pNext;										// переход к следующему элементу приемного списка
			Temp = Temp->pNext;												// переход к следующему элементу передающего списка
			sizeTemp++;
		}
		while (sizeTemp != this->size) {									// удаляем лишние элементы
			pop_back();														// через метод
		}
	}
	else {																	// иначе приемный список меньше
		Element* TempThis = this->Head;										// возьмем адрес приемного списка
		Element* Temp = Head.Head;											// возьмем адрес передаваемогосписка
		for (int i = 0; i < size; i++) {									// выполняем пока не перезапишим приемный список
			TempThis->Data = Temp->Data;									// данными переданного списка
			TempThis = TempThis->pNext;										// переход к следующему элементу приемного списка
			Temp = Temp->pNext;												// переход к следующему элементу передающего списка
		}
		for (; Temp; Temp = Temp->pNext) {									// добавление элементов
			push_back(Temp->Data);											// через метод
		}
	}
	cout << "MoveAssignment\t\t" << this << endl;
	return *this;
}
//operator+;
template<typename T>
List<T> List<T>::operator +(const List& Head) const {
	List list;
	Element* TempThis = this->Head;
	Element* Temp = Head.Head;
	for (int i = 0; i < this->size; i++) {
		list.push_back(TempThis->Data);
		TempThis = TempThis->pNext;
	}
	for (int i = 0; i < this->size; i++) {
		list.push_back(Temp->Data);
		Temp = Temp->pNext;
	}
	return list;
}
//operator+=;
template<typename T>
void List<T>::operator +=(const List& Head) {
	for (Element* temp = Head.Head; temp; temp = temp->pNext) {
		push_back(temp->Data);
	}
}
// вывод элементов в консоль прямой ход
template<typename T>
void List<T>::print() {
	cout << endl;
	//for (Element* Temp = Head; Temp; Temp = Temp->pNext)
		//cout << Temp->pPrev << tab <<  Temp << tab << Temp->Data << tab << Temp->pNext << endl;
	for (Iterator it = Head; it; it++)
		cout << *it << endl;

	cout << endl << tab << "Элементов в list: " << this->size << endl;
}
// вывод элементов в консоль обратный ход
template<typename T>
void List<T>::printRevers() {
	cout << endl;
	/*for (Element* Temp = Tail; Temp; Temp = Temp->pPrev)
		cout << Temp->pNext << tab << Temp << tab << Temp->Data << tab << Temp->pPrev << endl;
	*/
	for (ReversIterator it = Tail; it; it++)
		cout << *it << endl;

	cout << endl << tab << "Элементов в list: " << this->size << endl;
}